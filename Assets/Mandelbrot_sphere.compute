// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain

// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture
RWTexture2D<float4> Result;

float fXMin;
float fYMin;
float fResolution;
int nNumIterations;
static const float PI = 3.14159265f;
int width,height;

float2 sqrComplex(float2 z)
{
	return float2(z.x*z.x - z.y*z.y , 2*z.x * z.y);
}

float absSqrComplex(float2 z)
{
	return z.x*z.x + z.y*z.y;
}

float3 HUEtoRGB(in float H)
{
	float R = abs(H * 6 - 3) - 1;
	float G = 2 - abs(H * 6 - 2);
	float B = 2 - abs(H * 6 - 4);
	return saturate(float3(R,G,B));
}

float3 HSVtoRGB(in float3 HSV)
{
	float3 RGB = HUEtoRGB(HSV.x);
	return ((RGB - 1) * HSV.y + 1) * HSV.z;
}

float3 cmap(int n)
{
	float h = n/float(nNumIterations);
	return HUEtoRGB(h);
}

[numthreads(8,8,1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
	float theta = id.x * PI
	float2 c = id.xy * fResolution + float2(fXMin,fYMin);
	float2 z = float2(0,0);
	for ( int i=0 ; i<nNumIterations ; ++i)
	{
		z = sqrComplex(z) + c;
		if ( absSqrComplex(z) > 4 )
		{
			Result[id.xy] = float4(cmap(i),1);
			return;
		}
	}
	Result[id.xy] = float4(1,1,1,1);
}
